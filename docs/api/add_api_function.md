# Добавление новых функций API

Добавление новых функций в API может понадобится при модернизации ядра или разработке драйвера для устройства, которое не было предусмотрено создателем ядра.

## Структура файлов с исходным кодом API

Здесь можно посмотреть назначение файлов с исходным кодом API ядра. Это важно, ведь для изменения API необходимо понимать куда вносить изменения.

Файлы с исходным кодом API ядра находятся по пути [`src/api/`](../../src/api/)

### [api.c](../../src/api/api.c) / [api.h](../../src/api/api.h) 
Предназначены для приёма системных вызовов из user-space. Вызывает внутреннюю функцию-интерфейс ядра исходя из номера системного вызова. Внутренние функции-интерфейсы для user-space находятся в файлах `userspace_if.c` / `userspace_if.h`

### [userspace_if.c](../../src/api/userspace_if.c) / [userspace_if.h](../../src/api/userspace_if.h)
Файлы содержат функции-интерфейсы для userspace. Эти принимают:
- Адрес структуры, которая содержит значения регистров, то есть аргументы
- Адрес структуры, которая содержит результат, который затем будет записан в регистры

Сигнатура структуры:
``` c
// Структура предназначенная для хранения регистров
struct registers_struct {
    unsigned int eax;
    unsigned int ebx;
    unsigned int ecx;
    unsigned int edx;
    unsigned int esi;
    unsigned int edi;
};
```

Сигнатура функции-интерфейса:
``` c
void sys_example_func(struct registers_struct* args, struct registers_struct* result);
```

Функция-интерфейс вызывает внутреннюю функцию ядра, передавая ей аргументы не в структуре, а уже как полноценные аргументы. После возврата внутренняя функция ядра может вернуть значение (*зависит от спецификации*), оно должно быть записно в определённый *спецификацией* регистр по адресу структуры в result

Рассмотрим пример:

Существует внутренняя функция ядра:

``` c
int _example_func(int arg1, void* arg2, char* arg3); // Возвращает число
```

Вот как она будет вызываться в функции-интерфейсе:

``` c
void sys_example_func(struct registers_struct* args, struct registers_struct* result){
    int arg1 = (int)args->ebx; // Число
    void* arg2 = (void*)args->ecx; // Адрес
    char* arg3 = (char*)args->edx; // Адрес на массив символов
    int func_result = _example_func(arg1, arg2, arg3); // Вызываем функцию, передаём ей аргументы, получаем значение
    result->ebx = func_result; // Записываем результат в регистр ebx
}
```

### [general_functions.c](../../src/api/general_functions.c) / [general_functions.h](../../src/api/general_functions.h)

Эти файлы содержат **общие** функции ядра, т.е предназначенные и для user-space и для компонентов ядра

### [kernel_functions.c](../../src/api/kernel_functions.c) / [kernel_functions.h](../../src/api/kernel_functions.h)

Эти файлы содержат функции ядра только **для компонентов ядра**.

## Добавление функции

Для начала нужно определиться: функция должна быть доступна **только для компонентов ядра (kernel-space)** или **должна быть общей (kernel-space и user-space)**

### Только для компонентов ядра (kernel-space)

Краткий план действий:
- реализуем функцию в файлах `kernel_functions.c` и `kernel_functions.h`

### Общая (kernel-space и user-space

Краткий план действий:
- придумываем спецификацию для системного вызова
- реализуем функцию в файлах `general_functions.c` и `general_functions.h`
- добавляем функцию-интерфейс в файлы `userspace_if.c` и `userspace_if.h`
- добавляем обработчик системного вызова по его номеру
